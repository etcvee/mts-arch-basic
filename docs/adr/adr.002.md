# ADR.002 Способ интеграции

* Статус: Принято
* Владелец: ntkrnlmp@yandex.ru


## Контекст
Необходимо выбрать метод интеграции, структуру интеграции и способ взаимодействия и соответствие с требованиями:

* QR.005
* AC.001
* AC.002

## Варианты решения
<!--
  Примечание для проверяющего:

  По идее здесь надо было расписать варианты с методами интеграции и структурой,
  но т.к. этого явно не было указано в задании, описал только способ взаимодействия.
-->

### Вариант 1. Взаимодействие с помощью gRPC

gRPC (Remote Procedure Calls) — это система удалённого вызова процедур (RPC) с открытым исходным кодом, первоначально разработанная в Google в 2015 году. В качестве транспорта используется HTTP/2, в качестве языка описания интерфейса — Protocol Buffers. gRPC предоставляет такие функции как аутентификация, двунаправленная потоковая передача и управление потоком, блокирующие или неблокирующие привязки, а также отмена и тайм-ауты. Генерирует кроссплатформенные привязки клиента и сервера для многих языков. Чаще всего используется для подключения служб в микросервисном стиле архитектуры и подключения мобильных устройств и браузерных клиентов к серверным службам. 

Сложное использование HTTP/2 в gRPC делает невозможным реализацию клиента gRPC в браузере - вместо этого требуется прокси. 

### Вариант 2. Взаимодействие с помощью REST

REST — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. В определённых случаях это приводит к повышению производительности и упрощению архитектуры. В широком смысле компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов в сети Интернет. REST является альтернативой RPC.

Вызов удалённой процедуры может представлять собой обычный HTTP-запрос, а необходимые данные передаются в качестве параметров запроса.

### Сравнение вариантов

| Критерий                              | Оценка gRPC | Оценка REST |
| ------------------------------------- | ----------- | ----------- |
| Поддержка генерации кода              | 1           | 1           |
| Поддержка версионирования контрактов  | 1           | 1           |
| Поддержка веб-браузерами (из коробки) | 0           | 1           |
| Простота тестирования и отладки       | 2           | 4           |
| Скорость прототипирования             | 1           | 4           |
| Производительность                    | 4           | 3           |
| **Итого**                             | **9**       | **14**      |
## Решение

Для взаимодействия между Web-приложением и Backend for Frontend (BFF) мы используем HTTPS, т.к. протокол HTTP является стандартным протоколом для взаимодействия front-end и back-end, а TLS составляющая необходима для обеспечения безопасности данных.

Взаимодействия между BFF и внутренними микросервисами происходит в защищенной сети, поэтому необходимость в шифровании отсутствует, HTTPS сессия терминируется на BFF, далее используется HTTP.

В качестве архитектурного стиля мы используем REST, т.к. каждый микросервис построен вокруг агрегата (доклад, расписание, ...), поэтому удобно сделать RESTful API для манипуляции агрегатами. Для коммуникации между микросервисами мы используем HTTP, в качестве формата данных используем JSON. Т.к. пользовательское приложение является веб-приложением, а REST+JSON, в отличие от gRPC, имеет нативную поддержку со стороны веб-браузеров.

Выбор HTTP обусловлен использованием REST, который опирается на возможности протокола HTTP, такие как HTTP Method и HTTP Status Code, а так же наличием удобных инструментов, таких как Postman для тестирования и отладки микросервисов. 

Выбор JSON в качестве формата данных обусловлен универсальностью этого формата, хорошей степенью сжатия данных (при необходимости), а так же наличием удобных инструментов и сериализаторов.

Для онлайн стриминга используется протокол WebRTC, т.к. он поддерживается большинством браузеров.


## Последствия
Выбор REST и использование HTTP/1.1 ограничивает максимальную производительность системы, т.к. HTTP/2 в общем случае работает быстрее, чем HTTP/1.1. К примеру, в HTTP/1.1 отсутствует мультиплексирование, т.е. паралелльные запросы через одно соединение.

В рамках текущих требований производительности HTTP/1.1 достаточно для решения задачи, при необходимости предполагается использовать горизонтальное масштабирование.